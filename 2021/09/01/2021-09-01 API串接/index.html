<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<title>2021-09-01 API串接 | Bolin-Blog</title>


<link rel="stylesheet" href="../../../../styles/main.css">


    <meta name="generator" content="Hexo 5.4.0"></head>
    <body>
        <div class="container">
            <header>
<div class="main">
<div class="title">
    <a href="#" class="logo">Bolin-Blog</a>
</div>
<div class="site-nav">
    <ul id="menu" class="menu">
    
        <li class="menu-item text-underline">
            <a href="../../../../index.html">Home</a>
        </li>
    
        <li class="menu-item text-underline">
            <a href="../../../../archives">Archives</a>
        </li>
    
        <li class="menu-item text-underline">
            <a href="../../../../about">About</a>
        </li>
            
    </ul>
</div>
</div>
</header>
            <main class="main">
                <section class="posts clearfix">
<div class="post-wrapper">
    <article class="post article-entry">
    <div class="post-title">
        2021-09-01 API串接
    </div>
    <p class="sub">Sep 01 2021</p>
    <div class="post-content">
        <p>因為自己練習串接 Twitch API 做到一個段落，<br>所以記錄一下自己學了什麼，這篇主要針對 API 基礎的部分。</p>
<h1 id="API"><a href="#API" class="headerlink" title=" API"></a><strong><font color=#800000> API</font></strong></h1><p>Application Programming Interface(應用程式介面)，縮寫為<font color=#FF6600> API</font>，<br>簡單來說，是品牌開發出的一種接口，讓第三方可以開發、應用在自身的產品上的系統溝通介面。<br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=zvKadd9Cflc">點我在 Youtube 上看影片會更清楚。</a><br>不同公司，不一樣的工程師，設計的名稱都會不一樣，沒有統一的命名方式，<br>造成在引用各家 API 時，都需要詳讀 API 文件，理解所有設計命名規則後，才可使用。</p>
<h1 id="REST-amp-RESTful"><a href="#REST-amp-RESTful" class="headerlink" title=" REST &amp; RESTful "></a><strong><font color=#800000> REST &amp; RESTful </font></strong></h1><p><font color=#FF6600> REST</font>，Representational State Transfer( 表現層狀態轉移)，是一種設計風格。<br>以此規範設計的 API，稱為 <font color=#FF6600> RESTful API</font>。<br>RESTful API 主要由三種元件組成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Nouns 名詞：定義資源位置的 URL，每個資源在網路上都會有唯一的位置。</span><br><span class="line">Verbs 動詞：對資源要做的動作。</span><br><span class="line">Content Types 資源呈現方式：API 資源可以以多種方式表現，最常用的是 JSON，較輕也較好處理。</span><br></pre></td></tr></table></figure>
<p>一般的 API，可能會是這樣：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">獲得資料GET    /getData</span><br><span class="line">新增資料POST   /createData</span><br><span class="line">刪除資料DELETE /deleteData/1</span><br></pre></td></tr></table></figure>
<p>若以 RESTful API 風格開發的話：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">獲得資料GET     /data</span><br><span class="line">新增資料POST    /data</span><br><span class="line">刪除資料DELETE  /data/1</span><br></pre></td></tr></table></figure>
<p>基本上就是用一個 URL 定位資源，將動作藏在 HTTP 的 method 裡面。<br>使用 RESTful 風格設計的 API，就有了以下幾種優點及限制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">有唯一的URL表示資源位置，統一的 API 接口。(Uniform Interface)</span><br><span class="line">無狀態。(Stateless)</span><br></pre></td></tr></table></figure>
<p>RESTful 的狀態，即 HTTP 的請求狀態，一般 Web 服務中，Server 端和 Client 端交互的資訊，<br>會存在 Server 端的 Session (例如：已登入狀態)，<br>在 Client 端再次發送請求的時候，Server 端透過保存在 Server 端的 Session，去執行 request。<br>無狀態的意思，即 Client 端自行保存狀態，在請求 Server 的時候，一併附上給 Server 端，<br>Server 端無保存 Client 端的狀態資訊。<br><font color=#FF6600> 無狀態</font>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在用戶登錄系統時，Server 產生 token 紀錄 user 已登錄系統，</span><br><span class="line">然後把 token 還給 Client，在 Client 再次發送請求的時候，把 token 一起發給 Server，</span><br><span class="line">這樣 Server 就知道這一個 Client 是已經處於登錄的狀態。</span><br></pre></td></tr></table></figure>
<p><font color=#FF6600> 有狀態</font>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查詢員工工資：</span><br><span class="line">登錄系統。</span><br><span class="line">進入查詢工資的頁面。</span><br><span class="line">搜索該員工。</span><br><span class="line">點擊姓名查看工資。</span><br></pre></td></tr></table></figure>
<p>查詢工資的每一個步驟都依賴於前一個步驟，只要前置操作不成功，後續操作就無法執行。<br>如果輸入一個URL就可以直接得到指定員工的工資，這種情況就是無狀態的，因為獲取工資不依賴於其他資源或狀態。</p>
<h1 id="Web-API"><a href="#Web-API" class="headerlink" title=" Web API "></a><strong><font color=#800000> Web API </font></strong></h1><p>Web API，主要就是基於 HTTP 的網路服務，若設計符合 REST 原則，則可以稱為 RESTful API。<br>而 Web API 預設就支援 REST 這樣設計的風格，所以可以很輕易的建置 RESTful 服務。<br>Web API 特色：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">支援透過 HTTP 動詞 (GET、POST、PUT、DELETE) 表示的 CRUD 操作。</span><br><span class="line">請求的回覆可以透過 HTTP Status Code 來表達不同的含義，並且用戶端可以通過 Accept Header 來與服務協商。</span><br><span class="line">預設支援 XML 與 JSON 兩種資料格式的輸出，並且可以擴充增加其他格式。</span><br><span class="line">內建支援 OData 。</span><br><span class="line">可以接受或產生非物件的內容，如 images、PDF Files 等。</span><br><span class="line">支援 Self-Host 或 IIS Host。</span><br><span class="line">支援 ASP.NET MVC 的特性，能夠使用 Cache 機制，減少伺服器負載並加快反應的速度。</span><br></pre></td></tr></table></figure>
<p>Web API 優點：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">支援 ASP.NET 整合驗證。</span><br><span class="line">提高 Server Scalability(可擴展性) 的能力。</span><br><span class="line">支援快取，可改善反應時間以及 Server 的負載能力。</span><br><span class="line">不需要 Resource Discovery 機制，以降低程式耦合性。</span><br><span class="line">支援新的內容格式不需要丟掉舊的，如 XML 及現行前端常用的 JSON。</span><br><span class="line">集中商業邏輯程式，以避免過度分散的邏輯程式，以提高可維護性。</span><br></pre></td></tr></table></figure>
<h1 id="Ajax"><a href="#Ajax" class="headerlink" title=" Ajax "></a><strong><font color=#800000> Ajax </font></strong></h1><p>Ajax，全名是 Asynchronous JavaScript and XML，<br>重點在於 <font color=#FF6600> Asynchronous (非同步) </font>這個單字，<br>就是執行完之後就不管它了，不等結果回來就繼續執行下一行。<br>原本寫的 JavaScript 幾乎都是同步執行的。意思是他執行到某一行的時候，會等這行執行完畢，<br>才執行到下一行，確保執行順序。也就是說最後一行需要等很長一段時間才能執行到。<br>當 JavaScript 執行到 sendRequest 的時候，由於是同步的，就會等待 Response 回來才繼續做事。<br>換句話說，在 Response 還沒回來之前，整個 JavaScript 引擎是不會執行任何東西的。<br>像是這種已經預期到可能非常耗時間，不穩定的操作，就不能用同步的方式，而是要用非同步。<br>這邊需要特別注意的是「非同步的 Function 不能直接透過 return 把結果傳回來」，<br>要利用 <font color=#FF6600> Callback Function </font>，回呼函式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假設有個發送 Request 的函式叫做 sendRequest</span></span><br><span class="line">sendRequest(<span class="string">&#x27;https://api.twitch.tv/kraken/games/top?client_id=xxx&#x27;</span>, callMe);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callMe</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者寫成匿名函式</span></span><br><span class="line">sendRequest(<span class="string">&#x27;https://api.twitch.tv/kraken/games/top?client_id=xxx&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title=" XMLHttpRequest "></a><strong><font color=#800000> XMLHttpRequest </font></strong></h1><p>要發送 Request 的話，就要透過瀏覽器幫我們準備好的一個物件，叫做XMLHttpRequest，<br>範例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">request.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">`https://api.twitch.tv/helix/streams`</span>, <span class="literal">true</span>);</span><br><span class="line">request.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="comment">//指定當資料回來的時候，要用哪一個 function 去處理。</span></span><br><span class="line">  <span class="keyword">if</span> (request.status &gt;= <span class="number">200</span> &amp;&amp; request.status &lt; <span class="number">400</span>) &#123;</span><br><span class="line">    <span class="comment">// Success!</span></span><br><span class="line">    <span class="built_in">console</span>.log(request.responseText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">request.send();</span><br></pre></td></tr></table></figure>
<h1 id="同源政策-Same-Origin-Policy"><a href="#同源政策-Same-Origin-Policy" class="headerlink" title=" 同源政策(Same Origin Policy) "></a><strong><font color=#800000> 同源政策(Same Origin Policy) </font></strong></h1><p>如果從目前瀏覽器的網頁向跟自己「不同源」的網址發出請求和存取資料，<br>就是被視作「跨來源存取」，一般情況下是不允許的，只有「同源」才會被允許。<br>原因：這是基於網絡安全的考量，避免有駭客惡意呼叫其他人的網絡服務。<br>若沒有這個政策保護，別人就可以任意修改和存取你網頁裡的資源了。<br><font color=#FF6600> 注意 </font> ：請求 (request) 的確是有發出去，瀏覽器之後也有收到回應 (response)，<br>但瀏覽器因為同源政策，不把結果傳回給你的 JavaScript。<br>同源政策有兩種：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DOM 同源政策</span><br><span class="line">Cookie 同源政策</span><br></pre></td></tr></table></figure>

<h3 id="DOM-的同源政策"><a href="#DOM-的同源政策" class="headerlink" title="DOM 的同源政策"></a>DOM 的同源政策</h3><p>在瀏覽器裡載入的所有圖片、文字、程式碼等等的資源，會變成一個個 DOM 元素。<br>同源政策會禁止我去存取別人網站裡的 DOM 元素，即別人網站裡的網絡資源。<br>要判斷是否同源，就看這兩個網址在以下的部分是否相同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scheme (通訊協定，http, https不一樣)</span><br><span class="line">domain</span><br><span class="line">port (埠號，如有指定)</span><br></pre></td></tr></table></figure>
<h3 id="同源政策並非完全禁止跨來源存取"><a href="#同源政策並非完全禁止跨來源存取" class="headerlink" title="同源政策並非完全禁止跨來源存取"></a>同源政策並非完全禁止跨來源存取</h3><p>但在某些情況下，即使兩個網站是「不同源」，也可以允許存取的。<br>例如以下情況：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">跨來源寫入(Cross-origin writes）</span><br><span class="line">例如允許：表單送出(form)、連結(link)、重新導向(redirect)</span><br><span class="line"></span><br><span class="line">跨來源嵌入(Cross-origin embedding)</span><br><span class="line">例如允許：嵌入圖片&lt;img&gt;、影片&lt;video&gt;、&lt;iframe&gt;、放在 &lt; script &gt;裡的程式碼、</span><br><span class="line">CSS stylesheet、&lt;link rel=&quot;stylesheet&quot; href=&quot;...&quot;&gt; 等等。</span><br><span class="line">雖然網頁可以顯示這些資源，但我的 JavaScript 並不能讀取這些資源的內容。</span><br></pre></td></tr></table></figure>
<h3 id="Cookie-的同源政策"><a href="#Cookie-的同源政策" class="headerlink" title="Cookie 的同源政策"></a>Cookie 的同源政策</h3><p>Cookie 的同源跟以上所說的 DOM 同源有點不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">只要 domain 跟 Path 與 Cookie 上的一樣就會被視為同源。</span><br><span class="line">若經過一些設定才會判斷 scheme 要是 http 或 https。</span><br><span class="line">另外子網域與母網域的 Cookie 可以共用。</span><br></pre></td></tr></table></figure>

<h1 id="CORS-Cross-Origin-Resource-Sharing"><a href="#CORS-Cross-Origin-Resource-Sharing" class="headerlink" title=" CORS (Cross-Origin Resource Sharing) "></a><strong><font color=#800000> CORS (Cross-Origin Resource Sharing) </font></strong></h1><p>CORS，全名為 Cross-Origin Resource Sharing，跨來源資源共享。<br>這套規範跟你說，如果你想開啟跨來源 HTTP 請求的話，<br>Server 必須在 Response 的 Header 裡面加上<font color=#FF6600> Access-Control-Allow-Origin </font>。<br>當瀏覽器收到 Response 之後，會先檢查<font color=#FF6600> Access-Control-Allow-Origin </font>裡面的內容，<br>如果裡面有包含現在這個發起 Request 的 Origin 的話，就會允許通過，讓程式順利接收到 Response。</p>
<h1 id="JSONP"><a href="#JSONP" class="headerlink" title=" JSONP "></a><strong><font color=#800000> JSONP </font></strong></h1><p>除了以上設定，我們也可以透過<font color=#FF6600> JSONP (JSON with Padding) </font>  這個方法來解決。<br>剛才提過 &lt; script &gt; tag 是不受同源政策限制的，我們可以用它來解決問題。<br>我們常常引用 CDN 或是 Google Analytics 之類的第三方套件，<br>網址都是其他 Domain 的，但是卻能正常載入。<br>就是利用 &lt; script &gt; 的這個特性來達成跨來源請求的。<br>JSONP 的做法就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在一個 &lt;script&gt; tag 裡的放入伺服器端提供的網址，</span><br><span class="line">之後在另一個 &lt;script&gt; tag 裡宣告一個函式，</span><br><span class="line">函式名字是由伺服器端提供，也可以在伺服器端所提供的網址裡找到</span><br></pre></td></tr></table></figure>
<p><font color=#FF6600> 注意 </font>：雖然 JSONP 解決了跨來源問題，<br>但是 JSONP 只適用於 GET 請求，無法做到 POST，所以首選還是上面提及的 CORS 的方法。</p>
<h1 id="Preflight-Request"><a href="#Preflight-Request" class="headerlink" title=" Preflight Request "></a><strong><font color=#800000> Preflight Request </font></strong></h1><p>Preflight request 並不是我本身想要發出的請求。<br>Preflight request 是瀏覽器端發出請求前的一個<font color=#FF6600> 預檢請求 </font>，<br>這個預檢請求是負責查問伺服器，是否批准我們發出請求給它。<br>Preflight request 會帶有一些關於我想發的請求的一些資訊，<br>例如：我將會使用的 HTTP 請求方法(GET、POST…)、Authorization 等等。<br>當我發出的請求<font color=#FF6600> 不是簡單請求 </font>時，就會觸發 Preflight request，<br>當 Preflight request 被通過，我本身的請求才會被發出。</p>

    </div>
    </article>
</div>

    <div class="_toc">
        <strong class="toc-title">
        Contents
        </strong>
        <div class="toc-content">
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#API"><span class="toc-text"> API</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#REST-amp-RESTful"><span class="toc-text"> REST &amp; RESTful </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Web-API"><span class="toc-text"> Web API </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ajax"><span class="toc-text"> Ajax </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#XMLHttpRequest"><span class="toc-text"> XMLHttpRequest </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96-Same-Origin-Policy"><span class="toc-text"> 同源政策(Same Origin Policy) </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-%E7%9A%84%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96"><span class="toc-text">DOM 的同源政策</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96%E4%B8%A6%E9%9D%9E%E5%AE%8C%E5%85%A8%E7%A6%81%E6%AD%A2%E8%B7%A8%E4%BE%86%E6%BA%90%E5%AD%98%E5%8F%96"><span class="toc-text">同源政策並非完全禁止跨來源存取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie-%E7%9A%84%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96"><span class="toc-text">Cookie 的同源政策</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CORS-Cross-Origin-Resource-Sharing"><span class="toc-text"> CORS (Cross-Origin Resource Sharing) </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JSONP"><span class="toc-text"> JSONP </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Preflight-Request"><span class="toc-text"> Preflight Request </span></a></li></ol>
        </div>
    </div>

</section>


    <nav class="post-nav">
        
            <div class="page-tags">
                
                    <a href="../../../../tags/API/">API</a>
                
            </div>
        
    </nav>



    <nav class="paginator clearfix">
        
        
            <a class="next" href="../../../08/21/2021-08-21%20Webpack-Babel/">
                
                <span class="prev-text">2021-08-21 Webpack-module</span>
                <i class="iconfont icon-right"></i>
            </a>
        
    </nav>


            </main>
            <div class="copyright">
  <div class="text">Powered By
    <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/zjx137/hexo-theme-Tsu">Tsu</a> &copy 2019
  </div>
</div>

        </div>
    <div class="back-to-top" id="back-to-top">
            <i class="iconfont icon-up"></i>
    </div>
        
    </body>
    
<script src="../../../../js/jquery-3.3.1.min.js"></script>

    
<script src="../../../../js/back-to-top.js"></script>

    
<script src="../../../../js/scroll.js"></script>

    <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": { 
        preferredFont: "TeX", 
        availableFonts: ["STIX","TeX"], 
        linebreaks: { automatic:true }, 
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) 
    },
    tex2jax: { 
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ], 
        processEscapes: true, 
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {  
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, 
        Macros: { href: "{}" } 
    },
    messageStyle: "none"
    }); 
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

</html>
